var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this section, we will discuss the theoretical aspects of finding out the optimal strategy in executing a given program. The notion of optimal concerns two resources: time and space. By time we mean the number of basic operations it takes to compute a program. In this step, we are making a simplification of treating all operations having the same time. By space, we mean the number of registers needed for carrying out the basic operations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To put it more concretely, consider the program that computes Y = A * B + C. We may visualize the process of computation with the following computation graph.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The circles with alphabets in them denotes input data. The circles with operators in them denotes operations whose parameters are data in the head vertex of edges pointing to operator vertex. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The process of computation consists of loading data into register, performing operations on data in the register and storing the result to another register. When the data stored in a variable is loaded in the register, we mark the corresponding vertex in the computation graph as colored. Maximum number of vertices colored during the process of computaiton is the space cost of performing such computation. Consider the following example in [1]","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"There are two ways of performing the computation.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\n   r1 leftarrow c \n   r2 leftarrow x \n   r1 leftarrow r1 * r2 \n   r3 leftarrow b \n   r1 leftarrow r1 + r3 \n   r1 leftarrow r1 * r2 \n   r2 leftarrow a \n   r3 leftarrow r1 + r2 \nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Clearly, we used three registers","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\n   r1 leftarrow c \n   r2 leftarrow x \n   r1 leftarrow r1 * r2 \n   r3 leftarrow b  \n   r1 leftarrow r1 + r2 \n   r2 leftarrow x  \n   r1 leftarrow r1 * r2 \n   r2 leftarrow a  \n   r1 leftarrow r1 + r2 \nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"By reordering computation order, we are able to save one register. The question is that whether we have a way of automatically determining the best comptuaiton order that uses the least amount of registers. If so, how costly is the computation. What is the complexity class this problem resides in? The last question is important because a tight classification of complexity class for a problem will give us some idea about the structure of the problem and hence how to tackle it [2].","category":"page"},{"location":"theory/#Space-time-trade-off-for-Classical-Straight-Line-Program","page":"Theory","title":"Space-time trade off for Classical Straight Line Program","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Before discussing about the complexity class, let's formally define the problem.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given a stright-line program, we may first convert it into Static Single Assignment form. In the SSA form, each variable is only assigned once, therefore we could convert each assignment of the form X=A*B (let * denote arbitrary operation for here only) into three vertices in a directed graph. Edges are directed from the vertex representing A , B to the vertex representing the computation result of A*B.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is how the lower left three vertices came into being in the graph above. A well-defined computation will never use a variable that is used before assignment. Therefore, this graph will be a directed acyclic graph. Let this graph be denoted as G. [4]","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Each vertex in G may have two status, pebbled or unpebbled. For vertices with no in-coming edges, pebbling it means loading the value into a register. Unpebbling means to remove it from the register. They could be done at arbitrary time. For ther vertices, they could be pebbled only when the head of incoming edges are all populated. And, they could be unpebbled if they have been pebbled already. The process of computation is to pebble and unpebble vertices following the above rules and finally pebble the vertex representing the output variable. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let's call the problem of determining the minimum number of registers (pebbles) neede for a computation the standard pebble game. The input of the problem is G, the DAG representing the computational graph. The size of the input is V(G)+E(G), the number of vertices plus the number of edges in G.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"An accepted output for the problem is a number n and a witness w. n represents the minimum number of registers needed for computing the output variable. w is a computer program that can produce the optimal strategy of pebbling.","category":"page"},{"location":"theory/#One-shot-and-Unbounded-In-degree-Version","page":"Theory","title":"One-shot and Unbounded In-degree Version","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The earlest study of the complexity class for standard pebble game is done on DAGs with unbounded in-degree by [1] with additional one-shot rule on pebbling. Unbounded in-degree means a non-leaf vertex is computed with at most unlimited number of inputs. One-shot rule means any vertex can be pebbled at most once.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The original proof in [1] consists of an explicit reduction from 3-SAT problem to pebbling game. The 3-SAT problem is defined with m clauses and n variables.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Triangle nodes first, then initial node, then ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"You will need ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Furthermore, any DAG that can be pebbled with 2 pebbles is very boring, we conclude that unbounded in-degree version of one-shot standard pebble game is NP-Complete.","category":"page"},{"location":"theory/#General-Version","page":"Theory","title":"General Version","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next step is to consider whether unbounded in-degree standard pebble game allowing re-computation is NP-Complete or not. Unfortunately, as shown in reference [5] and [6] The number of steps for pebbling is not necessarily polynomially bounded. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In [6], a set of graphs G which is degree-2 acyclic directed graph are constructed. It was shown that the space-optimal pebbling strategy take mathcalO(2^sqrtn) time where n is the number of vertices in G.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Needs example.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Furthermore, it is shown to be PSPACE-Complete [5].","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A more intuition based proof is this. We know that RECHEABILITY is NL-COMPLETE [2]. This is because all you need to store in the limited memory is current vertex. For a graph with n vertices, this only needs mathcalO(log(n)) amount of space. The input of the problem is mathcalO(n^2) adjacency matrix of the graph. And some more rigorous proof will be needed to show that all other NL problems can be reduced to it.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Intuitively, pebbling game is NPSPACE-Complete: because it's input is a a computation graph of n vertices with constant size of pebble rule. But the actual graph you perform REACHABILITY is of size 2^n. We know the REACHABILITY question on a graph of size n is in NL-Complete with respect to input size n, therefore pebbling game is in NPSPACE-Complete with respcect to input size n [2]. Furthermore, by Savitch's theorem, we know standard pebbling game is also PSPACE-Complete.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Whether the standard pebble game is as hard as one-shot standard pebble game is upto debate because it reduces to the problem of textbfNP stackrel= textbfPSPACE. This is an unknown problem [2].","category":"page"},{"location":"theory/#Variants-and-Complexity","page":"Theory","title":"Variants and Complexity","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"There are other variants of the standard pebble game which corresponds to other computational models like reversible computation. A good place to start for references on what complexity class each of those problems are is this thesis [3].","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the sake of convinence, we copy the table that contains complexity class known for these variants here [3].","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Type of Game Unbounded  In-degree Bounded  In-degree Approximation (Additive) FPT\nStandard (one-shot) NP-complete [Set75] ? ? FPT [Thm 7.1]\nStandard PSPACE-complete PSPACE-complete [GLT79] n^1ε [Thm 5.1] ?\nBlack-white PSPACE-complete [HP1`] ? ? ?\nReversible PSPACE-complete PSPACE-complete [CLNV15] PSPACE-complete (Constant Factor)[CLNV15] ?\nRed-Blue PSPACE-complete [Thm 3.1] PSPACE-complete [Thm 3.1] ? W[1]-hard k Transitions [Thm 4.1]\nRed-Blue (no deletion) NP-complete [Thm 3.1] NP-complete [Thm 3.1] ? ?","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"What is the rigorous difference between NP-Complete and PSPACE-Complete problems? Why are we not certain that PSPACE-Complete problems are not equal to NP-Complete? Ref1 , Ref2.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Eventually, we would like to know from the complexity class of this problem whether tree-width related algorithms can help with solving our problem.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1]: (Sethi, Apr 1973)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[2]: (Moore and Mertens, 2011)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[3]: (Liu, 2017)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[4]: (Aho and Ullman, 1972)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[5]: (Paul and Tarjan, 1978)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[6]: (Gilbert et al., 1979)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<!– https://www.cs.toronto.edu/~toni/Papers/treewidth.pdf –>","category":"page"},{"location":"reference/#Bibliography","page":"Suggested Readings and References","title":"Bibliography","text":"","category":"section"},{"location":"reference/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Aho, A. V. and Ullman, J. D. (1972). Optimization of Straight Line Programs. SIAM Journal on Computing 1, 1–19, arXiv:https://doi.org/10.1137/0201002.\n\n\n\nGilbert, J. R.; Lengauer, T. and Tarjan, R. E. (1979). The pebbling problem is complete in polynomial space. In: Proceedings of the Eleventh Annual ACM Symposium on Theory of Computing, STOC '79 (Association for Computing Machinery, New York, NY, USA); pp. 237–248.\n\n\n\nLiu, Q. C. (2017). Red-blue and standard pebble games : complexity and applications in the sequential and parallel models.\n\n\n\nMacCormick, J. (2018). What Can Be Computed?: A Practical Guide to the Theory of Computation (Princeton University Press).\n\n\n\nMoore, C. and Mertens, S. (2011). The Nature of Computation (Oxford University Press, Inc., USA).\n\n\n\nPaul, W. and Tarjan, R. (1978). Time-space trade-offs in a pebble game. Acta Informatica 10, 111–115.\n\n\n\nSavage, J. (1998). Models of Computation: Exploring the Power of Computing (Addison-Wesley).\n\n\n\nSethi, R. (Apr 1973). Complete Register Allocation Problems. In: Proceedings of the Fifth Annual ACM Symposium on Theory of Computing, STOC '73 (Association for Computing Machinery, New York, NY, USA); pp. 182–195. Accessed on May 8, 2024.\n\n\n\n","category":"page"},{"location":"glossary/#glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Straight-line programs: Programs containing only read, output, computation     statements. A counter example is something that has loop and branches. For     formal definition see pp.38 of [1].","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Language: A set of strings from a given alphabet. An alphabet is a set of characters. For example, 01 is the binary alphabet. [2]","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Recoganizable: A language L is said to be recognizable by a program P if for all I in L, P(I) returns yes and for all I notin L, P(I) either is undefined ro P(I) return no.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"RECHEABILITY:  [3]","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"SPACE(f(n)): [3] A complexity class with restricted amount of space resource.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Savitch's Theorem [3] A theorem proving textbfNPSAPCE=textbfPSPACE. The reduction overhead is square.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"[1]: (Savage, 1998)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"[2]: (MacCormick, 2018)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"[3]: (Moore and Mertens, 2011)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PebbleGame","category":"page"},{"location":"#PebbleGame","page":"Home","title":"PebbleGame","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PebbleGame.","category":"page"}]
}
