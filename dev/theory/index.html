<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · PebbleGame.jl</title><meta name="title" content="Theory · PebbleGame.jl"/><meta property="og:title" content="Theory · PebbleGame.jl"/><meta property="twitter:title" content="Theory · PebbleGame.jl"/><meta name="description" content="Documentation for PebbleGame.jl."/><meta property="og:description" content="Documentation for PebbleGame.jl."/><meta property="twitter:description" content="Documentation for PebbleGame.jl."/><meta property="og:url" content="https://exAClior.github.io/PebbleGame.jl/theory/"/><meta property="twitter:url" content="https://exAClior.github.io/PebbleGame.jl/theory/"/><link rel="canonical" href="https://exAClior.github.io/PebbleGame.jl/theory/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PebbleGame.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Theory</a><ul class="internal"><li><a class="tocitem" href="#Space-time-trade-off-for-Classical-Straight-Line-Program"><span>Space-time trade off for Classical Straight Line Program</span></a></li></ul></li><li><a class="tocitem" href="../glossary/">Glossary</a></li><li><a class="tocitem" href="../reference/">Suggested Readings and References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/exAClior/PebbleGame.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/exAClior/PebbleGame.jl/blob/main/docs/src/theory.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h1><p>In this section, we will discuss the theoretical aspects of finding out the optimal strategy in executing a given program. The notion of optimal concerns two resources: time and space. By time we mean the number of basic operations it takes to compute a program. In this step, we are making a simplification of treating all operations having the same time. By space, we mean the number of registers needed for carrying out the basic operations.</p><p>To put it more concretely, consider the program that computes <span>$Y = A * B + C$</span>. We may visualize the process of computation with the following <a href="https://www.cs.cornell.edu/courses/cs5740/2017sp/lectures/04-nn-compgraph.pdf">computation graph</a>.</p><p><img src="../computation_graph.svg" alt/></p><p>The circles with alphabets in them denotes input data. The circles with operators in them denotes operations whose parameters are data in the head vertex of edges pointing to operator vertex. </p><p>The process of computation consists of loading data into register, performing operations on data in the register and storing the result to another register. When the data stored in a variable is loaded in the register, we mark the corresponding vertex in the computation graph as colored. Maximum number of vertices colored during the process of computaiton is the space cost of performing such computation. Consider the following example in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p><img src="../sethi_eg.svg" alt/></p><p>There are two ways of performing the computation.</p><ol><li></li></ol><p class="math-container">\[\begin{align*}
   r1 \leftarrow c \\
   r2 \leftarrow x \\
   r1 \leftarrow r1 * r2 \\
   r3 \leftarrow b \\
   r1 \leftarrow r1 + r3 \\
   r1 \leftarrow r1 * r2 \\
   r2 \leftarrow a \\
   r3 \leftarrow r1 + r2 \\
\end{align*}\]</p><p>Clearly, we used three registers</p><ol><li></li></ol><p class="math-container">\[\begin{align*}
   r1 \leftarrow c \\
   r2 \leftarrow x \\
   r1 \leftarrow r1 * r2 \\
   r3 \leftarrow b \\ 
   r1 \leftarrow r1 + r2 \\
   r2 \leftarrow x  \\
   r1 \leftarrow r1 * r2 \\
   r2 \leftarrow a \\ 
   r1 \leftarrow r1 + r2 \\
\end{align*}\]</p><p>By reordering computation order, we are able to save one register. The question is that whether we have a way of automatically determining the best comptuaiton order that uses the least amount of registers. If so, how costly is the computation. What is the complexity class this problem resides in? The last question is important because a tight classification of complexity class for a problem will give us some idea about the structure of the problem and hence how to tackle it <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><h2 id="Space-time-trade-off-for-Classical-Straight-Line-Program"><a class="docs-heading-anchor" href="#Space-time-trade-off-for-Classical-Straight-Line-Program">Space-time trade off for Classical Straight Line Program</a><a id="Space-time-trade-off-for-Classical-Straight-Line-Program-1"></a><a class="docs-heading-anchor-permalink" href="#Space-time-trade-off-for-Classical-Straight-Line-Program" title="Permalink"></a></h2><p>Before discussing about the complexity class, let&#39;s formally define the problem.</p><p>Given a <a href="../glossary/#glossary">stright-line program</a>, we may first convert it into <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static Single Assignment</a> form. In the SSA form, each variable is only assigned once, therefore we could convert each assignment of the form <span>$X=A*B$</span> (let <span>$*$</span> denote arbitrary operation for here only) into three vertices in a directed graph. Edges are directed from the vertex representing <span>$A$</span> , <span>$B$</span> to the vertex representing the computation result of <span>$A*B$</span>.</p><p><img src="../computation_graph.svg" alt/></p><p>This is how the lower left three vertices came into being in the graph above. A well-defined computation will never use a variable that is used before assignment. Therefore, this graph will be a directed acyclic graph. Let this graph be denoted as <span>$G$</span>. <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup></p><p>Each vertex in <span>$G$</span> may have two status, pebbled or unpebbled. For vertices with no in-coming edges, pebbling it means loading the value into a register. Unpebbling means to remove it from the register. They could be done at arbitrary time. For ther vertices, they could be pebbled only when the head of incoming edges are all populated. And, they could be unpebbled if they have been pebbled already. The process of computation is to pebble and unpebble vertices following the above rules and finally pebble the vertex representing the output variable. </p><p>Let&#39;s call the problem of determining the minimum number of registers (pebbles) neede for a computation the <em>standard pebble game</em>. The input of the problem is <span>$G$</span>, the <em>DAG</em> representing the computational graph. The size of the input is <span>$|V(G)|+|E(G)|$</span>, the number of vertices plus the number of edges in <span>$G$</span>.</p><p>An accepted output for the problem is a number <span>$n$</span> and a witness <span>$w$</span>. <span>$n$</span> represents the minimum number of registers needed for computing the output variable. <span>$w$</span> is a computer program that can produce the optimal strategy of pebbling.</p><h3 id="One-shot-and-Unbounded-In-degree-Version"><a class="docs-heading-anchor" href="#One-shot-and-Unbounded-In-degree-Version">One-shot and Unbounded In-degree Version</a><a id="One-shot-and-Unbounded-In-degree-Version-1"></a><a class="docs-heading-anchor-permalink" href="#One-shot-and-Unbounded-In-degree-Version" title="Permalink"></a></h3><p>The earlest study of the complexity class for standard pebble game is done on <span>$DAG$</span>s with unbounded in-degree by <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> with additional one-shot rule on pebbling. Unbounded in-degree means a non-leaf vertex is computed with at most unlimited number of inputs. One-shot rule means any vertex can be pebbled at most once.</p><p>The original proof in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> consists of an explicit reduction from 3-SAT problem to pebbling game. The <span>$3$</span>-SAT problem is defined with <span>$m$</span> clauses and <span>$n$</span> variables.</p><p>Triangle nodes first, then initial node, then </p><p>You will need </p><p>Furthermore, any <span>$DAG$</span> that can be pebbled with 2 pebbles is very boring, we conclude that unbounded in-degree version of one-shot standard pebble game is NP-Complete.</p><h3 id="General-Version"><a class="docs-heading-anchor" href="#General-Version">General Version</a><a id="General-Version-1"></a><a class="docs-heading-anchor-permalink" href="#General-Version" title="Permalink"></a></h3><p>The next step is to consider whether unbounded in-degree standard pebble game allowing re-computation is NP-Complete or not. Unfortunately, as shown in reference <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup> and <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup> The number of steps for pebbling is not necessarily polynomially bounded. </p><p>In <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>, a set of graphs <span>$\{G\}$</span> which is degree-<span>$2$</span> acyclic directed graph are constructed. It was shown that the space-optimal pebbling strategy take <span>$\mathcal{O}(2^{\sqrt{n}})$</span> time where <span>$n$</span> is the number of vertices in <span>$G$</span>.</p><p>Needs example.</p><p>Furthermore, it is shown to be PSPACE-Complete <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>.</p><p>A more intuition based proof is this. We know that <a href="../glossary/#glossary"><strong>RECHEABILITY</strong></a> is <span>$NL-COMPLETE$</span> <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. This is because all you need to store in the limited memory is current vertex. For a graph with <span>$n$</span> vertices, this only needs <span>$\mathcal{O}(log(n))$</span> amount of space. The input of the problem is <span>$\mathcal{O}(n^2)$</span> adjacency matrix of the graph. And some more rigorous proof will be needed to show that all other <span>$NL$</span> problems can be reduced to it.</p><p>Intuitively, pebbling game is <a href="../glossary/#glossary"><strong>NPSPACE-Complete:</strong></a> because it&#39;s input is a a computation graph of <span>$n$</span> vertices with constant size of pebble rule. But the actual graph you perform <strong>REACHABILITY</strong> is of size <span>$2^n$</span>. We know the <strong>REACHABILITY</strong> question on a graph of size <span>$n$</span> is in <strong>NL-Complete</strong> with respect to input size <span>$n$</span>, therefore pebbling game is in <strong>NPSPACE-Complete</strong> with respcect to input size <span>$n$</span> <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. Furthermore, by <a href="../glossary/#glossary">Savitch&#39;s theorem</a>, we know standard pebbling game is also <strong>PSPACE-Complete</strong>.</p><p>Whether the standard pebble game is as hard as one-shot standard pebble game is upto debate because it reduces to the problem of <span>$\textbf{NP} \stackrel{?}{=} \textbf{PSPACE}$</span>. This is an unknown problem <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><h3 id="Variants-and-Complexity"><a class="docs-heading-anchor" href="#Variants-and-Complexity">Variants and Complexity</a><a id="Variants-and-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Variants-and-Complexity" title="Permalink"></a></h3><p>There are other variants of the standard pebble game which corresponds to other computational models like reversible computation. A good place to start for references on what complexity class each of those problems are is this thesis <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><p>For the sake of convinence, we copy the table that contains complexity class known for these variants here <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><table><tr><th style="text-align: right">Type of Game</th><th style="text-align: right">Unbounded  In-degree</th><th style="text-align: right">Bounded  In-degree</th><th style="text-align: right">Approximation (Additive)</th><th style="text-align: right">FPT</th></tr><tr><td style="text-align: right">Standard (one-shot)</td><td style="text-align: right">NP-complete [Set75]</td><td style="text-align: right">?</td><td style="text-align: right">?</td><td style="text-align: right">FPT [Thm 7.1]</td></tr><tr><td style="text-align: right">Standard</td><td style="text-align: right">PSPACE-complete</td><td style="text-align: right">PSPACE-complete [GLT79]</td><td style="text-align: right"><span>$n^{1−ε}$</span> [Thm 5.1]</td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Black-white</td><td style="text-align: right">PSPACE-complete [HP1`]</td><td style="text-align: right">?</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Reversible</td><td style="text-align: right">PSPACE-complete</td><td style="text-align: right">PSPACE-complete [CLNV15]</td><td style="text-align: right">PSPACE-complete (Constant Factor)[CLNV15]</td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Red-Blue</td><td style="text-align: right">PSPACE-complete [Thm 3.1]</td><td style="text-align: right">PSPACE-complete [Thm 3.1]</td><td style="text-align: right">?</td><td style="text-align: right">W[1]-hard k Transitions [Thm 4.1]</td></tr><tr><td style="text-align: right">Red-Blue (no deletion)</td><td style="text-align: right">NP-complete [Thm 3.1]</td><td style="text-align: right">NP-complete [Thm 3.1]</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr></table><ol><li>What is the rigorous difference between NP-Complete and PSPACE-Complete problems? Why are we not certain that PSPACE-Complete problems are not equal to NP-Complete? <a href="https://www.quora.com/What-makes-any-NP-complete-problem-a-PSPACE-complete-problem-in-the-complexity-theory-field#:~:text=Every%20problem%20in%20NP%20is,problems%20are%20also%20PSPACE%2Dcomplete.">Ref1</a> , <a href="https://cs.stackexchange.com/questions/43723/what-is-practical-difference-between-np-and-pspace-complete">Ref2</a>.</li></ol><ol><li>Eventually, we would like to know from the complexity class of this problem whether tree-width related algorithms can help with solving our problem.</li></ol><p>&lt;!– https://www.cs.toronto.edu/~toni/Papers/treewidth.pdf –&gt;</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>(<a href="../reference/#Sethi1973">Sethi, Apr 1973</a>)</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>(<a href="../reference/#NoC">Moore and Mertens, 2011</a>)</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>(<a href="../reference/#Liu2017RedblueAS">Liu, 2017</a>)</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>(<a href="../reference/#doi:10.1137/0201002">Aho and Ullman, 1972</a>)</li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>(<a href="../reference/#Tarjan1978">Paul and Tarjan, 1978</a>)</li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a>(<a href="../reference/#10.1145/800135.804418">Gilbert <em>et al.</em>, 1979</a>)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../glossary/">Glossary »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 1 July 2024 05:41">Monday 1 July 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
